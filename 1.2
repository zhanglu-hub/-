#define预编译
define只是在预处理阶段将a替换成相应数值,具体替换的值只与define在文件中的位置有关和在哪个函数中无关
#define a 10
void foo();
void prin();
int main()
{
  prin();
  printf("%d",a);
  foo();
  printf("%d",a);
}
void foo()
{
#undef a 
#define a 50
}
void prin()
{
printf("%d",a);
}
输出:50 10 10
2.成员变量的初始化顺序
  (1)使用初始化列表初始化时,与构造函数中初始化成员列表的顺序无关,只与定义成员变量的顺序有关.
  (2)如果不使用初始化列表初始化,在构造函数内初始化时,此时与成员变量在构造函数中的位置有关.
  (3)类中const成员常量必须在构造函数初始化列表中初始化.
  (4)类中static成员变量,必须在类外初始化.
  class A
  {
  private:
  static int count;//类内声明
  static const int count =0;//静态常量成员.
  }
  int A::count=5;//类外定义并初始化,不需要再加static关键字
  为什么？
  静态成员属于整个类,不属于某个对象,如果在类内初始化,会导致static成员变量被定义多次.
  ！静态常量成员可以在类中初始化.
  变量初始化顺序：
  基类的静态变量或全局变量、派生类的静态变量或全局变量、基类的成员变量、派生类的成员变量.
3.const指针和指向const的指针
  const int* p1; // p1指向整型常量的指针
  int *const p2; // p2指向整型的常量指针
  int const* p3; //p3指向整型常量的指针
  顶层const表示指针本身是一个常量,底层const表示指针所指的对象是一个常量.
4.传入值参数和传入引用参数
  (1)传值
    把实参的值赋值给形参
    对形参的修改,不会影响实参的值
  (2)传引用
    真正的以地址的方式传递参数,传递之后,形参和实参都是同一个对象,只是他们名字不同而已
    对形参的修改将影响实参的值.
  为传入引用参数加上const？
  对象比较复杂的时候可以用引用,但是又不想改变它.
  (1)告诉编译器,这个参数是一个常量,在函数内部不能改变它;
  (2)在函数内部多次引用这个值,不用每次都重新读取,直接使用第一次读取的值.
